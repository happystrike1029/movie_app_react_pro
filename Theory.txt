▼ 리액트 관련 작업을 시작하기 전 설치해야 할 부분 
    > node.js 
    > npm 
    > npx 
    > Visual studio code
    > Git 
▼ 리액트 JS를 하기 전에 알아야 할 것 
    > HTML / CSS
        > div / span / flexbox / display / background color 
    > 바닐라 자바스크립트 
        > function / variable / classes 
        > return / arugument / variable / constants 
        > const / let / function(args)
    > node.js 
        > package.json 
▼ 리액트 쓰는 회사 
    > Airbnb, npm , facebook 
    > 리액트의 선호도는 점점 늘고 있는 편이며 추후에 리액트가 사라진다고 해도 여전히 자바스크립트의 지식은 향상된다. 

▼ create react app 
    > 하나의 명령을 실행해서 React Web App 을 set up 할 수 있게 해준다. 
    > cmd 창에 npx create-react-app movie_app_2021 을 입력해준다 (원하는 폴더내에 생성)
    > README.md 에 있는 내용을 전면수정 / package.json 에 있는 내용 중 scripts 에는 starts, build 를 제외한 나머지 삭제 
    > yarn 은 npm 과 같은 역할 

▼ git hub 안에 프로젝트를 넣어주기 (1.1)
    > git init 으로 파일을 담을 수 있는 빈공간을 만들어주고 
    > github 에 들어가서 repository를 만든 다음 
    > git status 해서 제대로 다 add 됐는지 확인 
        > 안됐으면 add 하고 commit 해주기 
    > git remote add origin https://github.com/happystrike1029/movie_app_react_pro.git
        git branch -M main
        git push -u origin main

▼ 리액트 구성 (1.2) 
    > index 목적에 맞춰 비워져 있음 
    > src 에서 초반 세팅을 위해 지워줄 것 (기본부터 알기 위해서)
    > 제일 처음 index.js 에서 삭제 
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './App';

    ReactDOM.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>,
    document.getElementById('root')
    );
        > 이 모양대로 내버려둔다. 
    
    > 다음 차례대로 파일 삭제 
        > LOGO / serviceWorker / index.css / app.test.js / app.css 
        > 남는 건 index.js 와 app.js 일 수 있게 
    
    > app.js 에서 남는 import 는 
        > import React from 'react'; 
        > 21년 버전에서는 상단과 같은 import 문구가 없었다, 그런데 작동은 했다. 
        > App.js 에서도 마찬가지로 내용은 다 삭제하고 아래와 같은 형식으로 남겨둔다. 
    import React from "react";

    function App() {
    return (
        <div className="App"/>
    );
    }
    export default App;

    > 그 다음에 다시 npm start 
    > 그 다음부터 수정된 사항은 브라우저에 자동으로 적용이 된다. 
        > 실험 1.  > <div> Hello 넣어보기 </div> 
            > 자동으로 refresh 되는 모습을 발견할 수 있다. 
    > 실행후 왼쪽 버튼 검사(f12)로 소스를 확인하면 div id ="root" 밑에 글이 들어가 있는걸 확인할 수 있다 
        > div id="root"는 어디에? > public 에 있는 index.html 안에 
    > react는 무엇인가 ? > react는 당신이 거기에 쓰는 모든 요소를 생성한다는 것 
        > 자바스크립트로 만들고 html로 넣어준다. 
        > 이 부분은 어떻게 실행이 돼 ? index.js 를 보면 보다 명확하게 알 수 있다. 
            > ReactDOM.render > application 을 render 
                                > 즉 import App from './App'; 부분을 렌더 해주려고 하는 것이다. 
                                > 리액트는 app.js 의 요소를 index.js 의 getElementById 를 통해 넣어주려고 한다. 
    > react 가 빠른 이유 
        > 소스코드에 처음부터 HTML 을 넣지 않고 HTML에서 HTML 을 추가하거나 제거하는 법을 알고 있기 때문 
        > application 이 로드할 때 빈 HTML 을 로드하게 되고  그 다음 react가 HTML 을 밀어넣게 된다. 
    > virtual DOM
        > virtual document object model 
        > 연관성 ? 존재하지 않는다는 말, 즉 index.html 소스코드에는 존재하지 않는다는 뜻이다.

▼ 첫 React Component 만들어보기 
> react를 살펴보기  
    > localhost를 계속 유지하기 위해서는 NPM start 를 실행하고 console을 종료하지 말아야 한다. 
    >  해당 페이지가 시작되지 않거나 찾을 수 없다는 메시지 > 서버를 제대로 실행하지 않았기 때문 
    > index.js 에 있는 App 을 component 라고 부른다. 
        > react 는 component와 함께 동작한다. 
        > component가 data를 보여주게 할 것 
        > component란? > HTML 을 반환하는 함수
            > 즉 우리는 function.application을 가지고 있고 이건 HTML을 반환한다. (App.js)
    > 자바스크립트와 HTML 사이의 이런 조합을 jsx 라고 부른다.
        > react에 특화된 개념이라 다른 곳에는 없는 유일한 것. 
        > App 하나만 렌더링 된다는 특징이 있다. 
            > 즉 내가 다른 파일 Potato.js 를 만든다고 해도 <App /> 옆에 <Potato />를 둔다고 실행되지 않는다. 
            > 이런때는 App.js 파일 안에 Potato를 import 시켜준다. 즉 이런 형태로. 
            
            import React from "react";
            import Potato from './Potato';

            function App() {
            return (
                // <div className="App"/>
                <div> 
                <h1>
                Hello~!!
                </h1>
                <Potato />
                </div>
            );
            }
            export default App;

    > react는 component를 가져와서 브라우저가 이해할 수 있는 평범한 일반 HTML로 만든다. 
    > !!! 즉 jsx는 javascript 안의 HTML이다. 
    > react application은 한 번에 하나의 component만 rendering(렌더링) 할 수 있다는 것 
        > 따라서 모든 것은 application 안에 들어가야 한다. 
    // 2.0의 형태 
    // function App() {
    //   return (
    //     // <div className="App"/>
    //     <div> 
    //       <h1>
    //        Hello~!!
    //       </h1>
    //       <Food fav="rice"
    //         // something = {true}
    //         // papapa = {["hello", 1, 2, 3, 4, true]}
    //       />
    //       <Food fav="noodle" />
    //       <Food fav="soup" />
    //     </div>
    //   );
    // }
    // export default App;`
▼ 재사용가능한 Component with JSX (2.1)
> import Potato 를 지우고도 사용할 수 있는 방법. 
    > App.js 내에 Potato function 을 만들어준다. 
    > react 의 장점 > 재사용 가능한 component를 만들 수 있다는 점, 계속해서 반복해서 사용 가능. 
    > component는 대문자로 시작해야하고, component로 정보를 보낼 수 있다. 
    > father 가 children 에게 data를 어떻게 보낼까? 
    > app이 어떻게 food에게 props를 사용해서 data를 보낼까? 
    > props란? 뭐든지 component에 넣게되는 것들. 
        > props는 어디로 가나? > argument로 간다. food의 첫번째 argument
    import React from "react";

    function Food({fav}){
    //만약 {fav}를 빼줬더라면 props를 가져와서 props의 fav를 입력해줘야 한다. 
    //console.log(props);
    return <h1>I like {fav}</h1>;
    }

    /*
    function Food(props){
    return <h1>I like {props.fav}</h1>;
    }
    */


    function App() {
    return (
        // <div className="App"/>
        <div> 
        <h1>
        Hello~!!
        </h1>
        <Food fav="rice" // fav 라는 이름의 property 를 rice라는 value 로 준 것 
            // something = {true}
            // papapa = {["hello", 1, 2, 3, 4, true]}
        />
        <Food fav="noodle" />
        <Food fav="soup" />
        </div>
    );
    }
    export default App;

    > 위와 같은 형태 
    > react를 통해 props 를 사용한다. > react는 전달한 props를 가져가는 일 
    > father component에서 children component로 원하는 많은 props를 보낼 수 있다. 
        > 모든 프로퍼티를 food function component의 인자로 넣을 것이다. 
    > es6의 버전을 적용시킨 최신 자바스크립트를 사용 
    > 내부에서 얻는 방법 > 인자값을 {} 내부에 써준다. props 가 아닌 props 내에 있는 세세한 인자값 
                        > 위와 같은 경우에는 {fav} 로 가져오기만 하면 된다. 
    > jsx 는 단지 HTML + javascript 

▼ 동적인 Component
> 위와 같은 형태는 전혀 효율적이지 못하다. 계속해서 복붙해 넣을 수도 없는 노릇. 
    > 데이터들은 웹사이트에서 온 데이터들, 갖고 있지 않은 데이터를 붙여 넣는 작업은 할수 없다.  
> 웹사이트에 동적인 데이터를 추가하는 방법. 
    > array 로 데이터를 쌓고 자동적으로 food를 이름, 이미지 순으로 렌더링 하는 법? 
        > 자바스크립트 함수를 사용한다. map 을 사용하는 법 
    > map 은 array의 각 item에서 function을 실행하는 자바스크립트 function 
        > function의 result 를 갖는 array를 다시 던져준다. 
        > const friends = ["LEE", "KIM", "HWANG", "HAN"];
        friends.map(current => {
            cosole.log(current);
            return 0
        });

        // 옛날 버전은 아래와 같다
        friends.map(function(current){
            console.log(current);
            return 0;
        });
        > 해석 : map 은 funciton을 취해서 그 funciton을 array의 각 item에 적용 
                : array [0,0,0,0]의 형태를 갖게 된다. 
        
        > 심화버전 2
        friends.map(friend => {
            return friend + S2;
        });

        function App() {
        return (
            // <div className="App"/>
            <div> 
            {foodILike.map(dish => (<Food name={dish.name} picture={dish.image}/>))}
            </div>
            // dish는 object 
        );
        }
        export default App;
        > 위와 같은 형태로 작성 

▼  map 요약 (심화단계)
> function 을 하나 더 만드는 것 
    > map 에 function 만 담는 경우 그렇게 한다. 
    > {foodILike.map(renderFood)} 인 경우에만 
    Warning: Each child in a list should have a unique "key" prop. 
        > react의 element들은 유일해야 하고 list 안으로 집어넣을때 유일성을 잃어버린다는 의미 
        > 즉 id를 추가해준다. 
        > key={dish.id}를 추가해줌 , 리액트 내부에서 사용되는 거기때문에 에러는 사라진다. 
        > alt={name}은 시각장애인분들을 위한 것 
    > 다음에는 props에 대해 더 명확하게 할 것
        > props에 따라서 해당 글이 사라질수도, 이미지가 깨질수도 있기 때문에 우리가 원하는 props이 우리가 갖고 있는 props인지 체크하는 방법이 필요하다. 

▼ props 체크 
> father component로 부터 전달받은 props가 우리가 예상한 props인지를 알아야 한다. 
    > rating 을 달아준다. 
    > node.js 에 따로 설치해줘야 함 (npm i prop-types)
        > 항상 주의할 것 cd movie_app_2021 경로에서 설치해주기 상위 경로로 하면 인식을 못함 
        > prop-types 의 역할 > 만약 picture라는 props가 잘못해서 images 로 들어갔을 때 이 component는 동작하지 않을거라고 알려주는 역할 
        > Food.propTypes = {
        name: PropTypes.string.isRequired,
        picture : PropTypes.string.isRequired,
        rating:PropTypes.string.isRequired
        }; << 로 사용되나 강의에서 본 PropTypes는 사용할 수 없다. 대소문자를 구분하기 때문에. 
        > 추후에 콘솔을 확인하면 prop type 관련 에러가 떠있다 
            > rating의 type이 현재 숫자로 제공 됐지만 string을 기대하고 있다는 뜻
            > number 로 바꿔주면 관련 에러가 사라진다.  
            > 즉 콘솔을 확인하면서 에러를 체크할 수 있게 해주는 역할을 한다는 뜻 
            > isRequired도 매번 쓸 필요 없다. 하지만 필수가 아니라는 뜻이기 때문에 에러가 없어짐. 
                > undefined, number만 읽기 때문 
            > propTypes react를 따로 찾아보면 관련 문서가 나온다. 
            > 필수로 알아야 하는 것들 : jspx, props, state 

    
// import React from "react";
// import PropTypes from "prop-types";
// // 2.1 렌더링 하는 법 
// const foodILike = [
//   {
//     id:1,
//     name: "Kimchi",
//     image:
//       "http://aeriskitchen.com/wp-content/uploads/2008/09/kimchi_bokkeumbap_02-.jpg"
//     ,rating : 5
//   },
//   {
//     id:2,
//     name: "Samgyeopsal",
//     image:
//       "https://3.bp.blogspot.com/-hKwIBxIVcQw/WfsewX3fhJI/AAAAAAAAALk/yHxnxFXcfx4ZKSfHS_RQNKjw3bAC03AnACLcBGAs/s400/DSC07624.jpg"
//     ,rating : 4.5
//   },
//   {
//     id:3,
//     name: "Bibimbap",
//     image:
//       "http://cdn-image.myrecipes.com/sites/default/files/styles/4_3_horizontal_-_1200x900/public/image/recipes/ck/12/03/bibimbop-ck-x.jpg?itok=RoXlp6Xb"
//     ,rating : 4.7
//   },
//   {
//     id:4,
//     name: "Doncasu",
//     image:
//       "https://s3-media3.fl.yelpcdn.com/bphoto/7F9eTTQ_yxaWIRytAu5feA/ls.jpg"
//     ,rating : 4.4
//   },
//   {
//     id:5,
//     name: "Kimbap",
//     image:
//       "http://cdn2.koreanbapsang.com/wp-content/uploads/2012/05/DSC_1238r-e1454170512295.jpg"
//     ,rating : 4.6
//   }
// ];

// function Food({name, picture, rating}){
//   return (
//     <div>
//     <h1>I like {name}</h1>
//     <h4>{rating}/5.0</h4>
//     <img src={picture} alt={name} />
//   </div>
//   );
// }

// Food.propTypes = {
//   name: PropTypes.string.isRequired,
//   picture : PropTypes.string.isRequired,
//   rating:PropTypes.number.isRequired
// };

// function App() {
//   return (
//     <div> 
//       {foodILike.map(dish =>(
//         <Food key={dish.id} name={dish.name} picture={dish.image} rating={dish.rating}/>
//       ))}
//     </div>
//     // dish는 object 
//   );
// }
// export default App;

>> 여기까지가 2.4 까지의 소스 
